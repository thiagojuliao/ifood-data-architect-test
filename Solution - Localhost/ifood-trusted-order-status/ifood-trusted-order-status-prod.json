{"paragraphs":[{"text":"%pyspark\n\n###############################################\n#   Importando pacotes & definindo funções    #\n###############################################\n\nfrom datetime import *\nfrom pyspark import StorageLevel\nfrom pyspark.sql import SparkSession\nfrom pyspark.sql.functions import *\nfrom pyspark.sql.types import *\n\n###############################\n#   Definição de variáveis    #\n###############################\n\n# Referência de processamento\nref = str(datetime.today() - timedelta(days=1))\n\n# Caminho de origem da raw order status\norigem_raw = \"hdfs://localhost:9000/ifood-raw-order-status/dt={}/*.parquet\".format(ref)\n\n# Caminho de destino da trusted order status\ndestino_trusted = \"hdfs://localhost:9000/ifood-trusted-order-status/\"\n\n# Inicia sessão spark\nspark = SparkSession.builder.appName(\"ifood-trusted-order-status-dev\").getOrCreate()\n\n# Configurações básicas para o spark\nspark.conf.set(\"spark.sql.maxPartitionBytes\", 200 * 1024 * 1024) # Seta a quantidade máxima de bytes em uma partição ao ler os arquivos de entrada (Entre 100MB e 200MB é o ideal)\nspark.conf.set(\"spark.sql.sources.partitionOverwriteMode\", \"DYNAMIC\") # Necessário para sobrescrever partições","user":"anonymous","dateUpdated":"2019-12-25T10:34:29-0300","config":{"editorSetting":{"language":"python","editOnDblClick":false,"completionKey":"TAB","completionSupport":true},"colWidth":12,"editorMode":"ace/mode/python","fontSize":9,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[]},"apps":[],"jobName":"paragraph_1577277359500_-915596451","id":"20191223-012630_1390010523","dateCreated":"2019-12-25T09:35:59-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"focus":true,"$$hashKey":"object:27"},{"title":"Lê a origem","text":"%pyspark\n\n# Lê a base raw order status\nrawDF = spark.read.parquet(origem_raw)","user":"anonymous","dateUpdated":"2019-12-25T09:35:59-0300","config":{"editorSetting":{"language":"python","editOnDblClick":false,"completionKey":"TAB","completionSupport":true},"colWidth":12,"editorMode":"ace/mode/python","fontSize":9,"title":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[]},"apps":[],"jobName":"paragraph_1577277359503_-342410669","id":"20191223-012858_808752653","dateCreated":"2019-12-25T09:35:59-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:28"},{"title":"Pivoteia a tabela","text":"%pyspark\n\n# Pivoteia a tabela a fim de termos os valores dos status de cada ordem em colunas distintas\npivotDF = rawDF \\\n    .drop(\"dt_proc\") \\\n    .withColumn(\"created_at\", col(\"created_at\").cast(TimestampType())) \\\n    .withColumn(\"created_at\", unix_timestamp(\"created_at\")) \\\n    .groupBy(\"order_id\", \"dt\") \\\n    .pivot(\"value\", [\"REGISTERED\", \"PLACED\", \"CONCLUDED\", \"CANCELLED\"]) \\\n    .min(\"created_at\") \\\n    .withColumn(\"registered\", to_timestamp(\"REGISTERED\")) \\\n    .withColumn(\"placed\", to_timestamp(\"PLACED\")) \\\n    .withColumn(\"concluded\", to_timestamp(\"CONCLUDED\")) \\\n    .withColumn(\"cancelled\", to_timestamp(\"CANCELLED\")) \\\n    .withColumn(\"dt_proc\", current_date())","user":"anonymous","dateUpdated":"2019-12-25T10:29:43-0300","config":{"editorSetting":{"language":"python","editOnDblClick":false,"completionKey":"TAB","completionSupport":true},"colWidth":12,"editorMode":"ace/mode/python","fontSize":9,"title":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[]},"apps":[],"jobName":"paragraph_1577277359504_-108872397","id":"20191223-013047_257641669","dateCreated":"2019-12-25T09:35:59-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:29"},{"title":"Grava no diretório final","text":"%pyspark\n\n# Grava a tabela no diretório final\n# 125MB correspondem a aproximadamente 2.400.000 linhas\nnum_de_linhas = pivotDF.count()\ntotal_de_particoes = num_de_linhas / 2400000\n\nif total_de_particoes == 0:\n    total_de_particoes = 1\n    \npivotDF \\\n    .repartition(total_de_particoes) \\\n    .write.mode(\"overwrite\") \\\n    .partitionBy(\"dt\") \\\n    .option(\"compression\", \"snappy\") \\\n    .format(\"parquet\") \\\n    .save(destino_trusted)","user":"anonymous","dateUpdated":"2019-12-25T09:35:59-0300","config":{"editorSetting":{"language":"python","editOnDblClick":false,"completionKey":"TAB","completionSupport":true},"colWidth":12,"editorMode":"ace/mode/python","fontSize":9,"title":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[]},"apps":[],"jobName":"paragraph_1577277359505_-275746842","id":"20191223-014952_2099873042","dateCreated":"2019-12-25T09:35:59-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:30"},{"title":"Validação","text":"%pyspark\n\n# Leitura da base final\ntrustedDF = spark.read.parquet(destino_trusted) \\\n    .select(\n        \"order_id\", \n        expr(\"registered as registered_\"), \n        expr(\"placed as placed_\"), \n        expr(\"concluded as concluded_\"), \n        expr(\"cancelled as cancelled_\")) \\\n    .orderBy(\"order_id\")\n\n# Monta a tabela comparativa\ncompDF = rawDF \\\n    .groupBy(\"order_id\", \"value\") \\\n    .agg(min(\"created_at\").alias(\"created_at\")) \\\n    .withColumn(\"registered\", expr(\"case when value == 'REGISTERED' then created_at else null end\")) \\\n    .withColumn(\"placed\", expr(\"case when value == 'PLACED' then created_at else null end\")) \\\n    .withColumn(\"concluded\", expr(\"case when value == 'CONCLUDED' then created_at else null end\")) \\\n    .withColumn(\"cancelled\", expr(\"case when value == 'CANCELLED' then created_at else null end\")) \\\n    .withColumn(\"registered\", col(\"registered\").cast(TimestampType())) \\\n    .withColumn(\"placed\", col(\"placed\").cast(TimestampType())) \\\n    .withColumn(\"concluded\", col(\"concluded\").cast(TimestampType())) \\\n    .withColumn(\"cancelled\", col(\"cancelled\").cast(TimestampType())) \\\n    .drop(\"value\") \\\n    .orderBy(\"order_id\") \n\n#compDF.show(5, False)\n\n# Compara as variáveis e valida os resultados\nvalidaDF = compDF \\\n    .join(trustedDF, on=[\"order_id\"], how=\"left\") \\\n    .withColumn(\"fl_registered\", expr(\"case when coalesce(registered, registered_, '9999-12-31 00:00:00') = coalesce(registered_, '9999-12-31 00:00:00') then 0 else 1 end\")) \\\n    .withColumn(\"fl_placed\", expr(\"case when coalesce(placed, placed_, '9999-12-31 00:00:00') = coalesce(placed_, '9999-12-31 00:00:00') then 0 else 1 end\")) \\\n    .withColumn(\"fl_concluded\", expr(\"case when coalesce(concluded, concluded_, '9999-12-31 00:00:00') = coalesce(concluded_, '9999-12-31 00:00:00') then 0 else 1 end\")) \\\n    .withColumn(\"fl_cancelled\", expr(\"case when coalesce(cancelled, cancelled_, '9999-12-31 00:00:00')  = coalesce(cancelled_, '9999-12-31 00:00:00') then 0 else 1 end\"))\n\n# Faz a contagem de valores desiguais\nerrosDF = validaDF \\\n    .withColumn(\"dummy\", lit(\"1\")) \\\n    .groupBy(\"dummy\") \\\n    .agg(\n        sum(\"fl_registered\").alias(\"err_registered\"),\n        sum(\"fl_placed\").alias(\"err_placed\"),\n        sum(\"fl_concluded\").alias(\"err_concluded\"),\n        sum(\"fl_cancelled\").alias(\"err_cancelled\")) \\\n    .withColumn(\"total\", col(\"err_registered\") + col(\"err_placed\") + col(\"err_concluded\") + col(\"err_cancelled\"))\n\ntotal_de_erros = errosDF.select(\"total\").take(1)[0][\"total\"]\n\nprint(\"> Total de valores desiguais confirmados: {}\".format(total_de_erros))","user":"anonymous","dateUpdated":"2019-12-25T09:35:59-0300","config":{"editorSetting":{"language":"python","editOnDblClick":false,"completionKey":"TAB","completionSupport":true},"colWidth":12,"editorMode":"ace/mode/python","fontSize":9,"title":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"> Total de valores desiguais confirmados: 0\n"}]},"apps":[],"jobName":"paragraph_1577277359505_-287015931","id":"20191223-020948_1107924447","dateCreated":"2019-12-25T09:35:59-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:31"},{"text":"%pyspark\n","user":"anonymous","dateUpdated":"2019-12-25T09:35:59-0300","config":{"editorSetting":{"language":"python","editOnDblClick":false,"completionKey":"TAB","completionSupport":true},"colWidth":12,"editorMode":"ace/mode/python","fontSize":9,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1577277359506_1164550376","id":"20191223-041847_483506837","dateCreated":"2019-12-25T09:35:59-0300","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:32"}],"name":"ifood-trusted-order-status-prod","id":"2EWQBNET1","noteParams":{},"noteForms":{},"angularObjects":{},"config":{"isZeppelinNotebookCronEnable":false,"looknfeel":"default","personalizedMode":"false"},"info":{}}