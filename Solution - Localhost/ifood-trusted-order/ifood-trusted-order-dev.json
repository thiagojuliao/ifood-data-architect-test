{"paragraphs":[{"text":"%pyspark\n\n###############################################\n#   Importando pacotes & definindo funções    #\n###############################################\n\nfrom datetime import *\nfrom pyspark import StorageLevel\nfrom pyspark.sql import SparkSession\nfrom pyspark.sql.functions import *\nfrom pyspark.sql.types import *\n\n# Função para criptografar colunas de um dataframe\ndef criptografa_df(dataframe, colunas_a_criptografar):\n    colunas = []\n    \n    for coluna in dataframe.columns:\n        if coluna in colunas_a_criptografar:\n            aux = sha2(col(coluna), 0).alias(coluna)\n        else:\n            aux = coluna\n        colunas.append(aux)\n    return colunas\n\n###############################\n#   Definição de variáveis    #\n###############################\n\n# Lista de colunas a serem criptografadas\ncripto_ls = [\"cpf\", \"customer_name\", \"delivery_address_city\", \"delivery_address_district\", \"delivery_address_country\", \"delivery_address_district\", \n    \"delivery_address_latitude\", \"delivery_address_longitude\", \"delivery_address_state\", \"delivery_address_zip_code\", \"customer_phone_area\", \n    \"customer_phone_number\", \"merchant_zip_code\"]\n\n# Ordem das colunas na base final\ncolunas = [\"order_id\", \"customer_id\", expr(\"cpf as customer_cpf\"), \"customer_name\", \"customer_phone_area\", \"customer_phone_number\", expr(\"language as customer_language\"), \n    \"costumer_created_at\", expr(\"active as is_costumer_active\"), \"merchant_id\", \"merchant_created_at\", expr(\"enabled as is_merchant_enabled\"), \n    expr(\"price_range as merchant_price_range\"), expr(\"average_ticket as merchant_average_ticket\"), expr(\"takeout_time as merchant_takeout_time\"), \n    expr(\"delivery_time as merchant_delivery_time\"), expr(\"minimum_order_value as merchant_minimum_order_value\"), \"merchant_zip_code\", \"merchant_city\",\n    \"merchant_state\", \"merchant_country\", \"merchant_latitude\", \"merchant_longitude\", \"merchant_timezone\", \"delivery_address_city\", \n    \"delivery_address_country\", \"delivery_address_district\", \"delivery_address_external_id\", \"delivery_address_latitude\", \"delivery_address_longitude\", \n    \"delivery_address_state\", \"delivery_address_zip_code\", expr(\"items as order_items\"), \"order_created_at\", expr(\"order_scheduled as is_order_scheduled\"),\n    \"order_scheduled_date\", \"order_total_amount\", \"origin_platform\", \"order_status\"]\n\n# Caminho de origem da raw order\norigem_order = \"hdfs://localhost:9000/ifood-raw-order/\"\n\n# Caminho de origem da raw order status\norigem_status = \"hdfs://localhost:9000/ifood-raw-order-status/\"\n\n# Caminho de origem da raw restaurant\norigem_rest = \"hdfs://localhost:9000/ifood-raw-restaurant/\"\n\n# Caminho de origem da raw consumer\norigem_cons = \"hdfs://localhost:9000/ifood-raw-consumer/\"\n\n# Caminho de destino da trusted order\ndestino_trusted = \"hdfs://localhost:9000/ifood-trusted-order/\"\n\n# Inicia sessão spark\nspark = SparkSession.builder.appName(\"ifood-trusted-order-dev\").getOrCreate()\n\n# Configurações básicas para o spark\nspark.conf.set(\"spark.sql.maxPartitionBytes\", 200 * 1024 * 1024) # Seta a quantidade máxima do tamanho das partições ao ler os arquivos de entrada\nspark.conf.set(\"spark.sql.sources.partitionOverwriteMode\", \"DYNAMIC\") # Necessário para sobrescrever partições\nspark.conf.set(\"spark.sql.autoBroadcastJoinThreshold\", 100 * 1024 * 1024) # Define o limiar para broadcasting de até 100MB\nspark.conf.set(\"spark.default.parallelism\", 100) # Define a quantidade de tasks a serem executadas em paralelo","user":"anonymous","dateUpdated":"2019-12-25T12:52:28-0300","config":{"lineNumbers":false,"editorSetting":{"language":"python","editOnDblClick":false,"completionKey":"TAB","completionSupport":true},"colWidth":12,"editorMode":"ace/mode/python","fontSize":9,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[]},"apps":[],"jobName":"paragraph_1577281242310_1076845491","id":"20191223-114810_835126986","dateCreated":"2019-12-25T10:40:42-0300","status":"FINISHED","progressUpdateIntervalMs":500,"focus":true,"$$hashKey":"object:2440","dateFinished":"2019-12-25T11:05:58-0300","dateStarted":"2019-12-25T11:05:58-0300"},{"title":"Lê as origens order e order-status","text":"%pyspark\n\n# Lê a raw order\norderDF = spark.read.parquet(origem_order).drop(\"dt\", \"dt_proc\").filter(col(\"dt\") == \"2019-01-01\")\n\n# Lê a raw order status\nstatusDF = spark.read.parquet(origem_status).drop(\"dt\", \"dt_proc\").filter(col(\"dt\") == \"2019-01-01\")\n\n# Lê a raw restaurant\nrestDF = spark.read.parquet(origem_rest).drop(\"dt\", \"dt_proc\")\n\n# Lê a raw consumer\nconsDF = spark.read.parquet(origem_cons).drop(\"dt\", \"dt_proc\")","user":"anonymous","dateUpdated":"2019-12-25T11:08:06-0300","config":{"editorSetting":{"language":"python","editOnDblClick":false,"completionKey":"TAB","completionSupport":true},"colWidth":12,"editorMode":"ace/mode/python","fontSize":9,"title":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[]},"apps":[],"jobName":"paragraph_1577281242311_70269951","id":"20191223-120737_447564544","dateCreated":"2019-12-25T10:40:42-0300","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:2441","dateFinished":"2019-12-25T11:08:24-0300","dateStarted":"2019-12-25T11:08:06-0300"},{"title":"Pegamos apenas os status mais recentes de cada pedido","text":"%pyspark\n\n# Status mais recentes de cada pedido\nstatusDF_ = statusDF \\\n    .withColumn(\"order\", expr(\"row_number() over(partition by order_id order by order_id, created_at desc)\")) \\\n    .filter(col(\"order\") == 1) \\\n    .select(\"order_id\", \"created_at\", expr(\"value as order_status\"))\n    \n#statusDF_.show(5, False)","user":"anonymous","dateUpdated":"2019-12-25T11:08:36-0300","config":{"editorSetting":{"language":"python","editOnDblClick":false,"completionKey":"TAB","completionSupport":true},"colWidth":12,"editorMode":"ace/mode/python","fontSize":9,"title":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[]},"apps":[],"jobName":"paragraph_1577281242312_-547429353","id":"20191223-121509_717017178","dateCreated":"2019-12-25T10:40:42-0300","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:2442","dateFinished":"2019-12-25T11:08:36-0300","dateStarted":"2019-12-25T11:08:36-0300"},{"title":"Cruzando com a base orders","text":"%pyspark\n\n# Otimização do join\nspark.conf.set(\"spark.sql.shuffle.partitions\", int(spark.conf.get(\"spark.default.parallelism\")))\norderDF \\\n    .write.mode(\"overwrite\") \\\n    .bucketBy(int(spark.conf.get(\"spark.default.parallelism\")), \"order_id\") \\\n    .option(\"compression\", \"snappy\") \\\n    .format(\"parquet\") \\\n    .saveAsTable(\"orders\")\n    \norderDF_ = spark.read.table(\"orders\")\n\nstatusDF_ \\\n    .write.mode(\"overwrite\") \\\n    .bucketBy(int(spark.conf.get(\"spark.default.parallelism\")), \"order_id\") \\\n    .option(\"compression\", \"snappy\") \\\n    .format(\"parquet\") \\\n    .saveAsTable(\"status\")\n    \nstatusDF_ = spark.read.table(\"status\")\n    \n# Traz os status mais recentes de cada pedido\njoin00 = orderDF_.join(statusDF_, on=[\"order_id\"], how=\"left\")","user":"anonymous","dateUpdated":"2019-12-25T11:08:41-0300","config":{"editorSetting":{"language":"python","editOnDblClick":false,"completionKey":"TAB","completionSupport":true},"colWidth":12,"editorMode":"ace/mode/python","fontSize":9,"title":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[]},"apps":[],"jobName":"paragraph_1577281242313_-1103298665","id":"20191223-122852_2071888743","dateCreated":"2019-12-25T10:40:42-0300","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:2443","dateFinished":"2019-12-25T11:09:18-0300","dateStarted":"2019-12-25T11:08:41-0300"},{"title":"Tratamento de duplicidade na base order","text":"%pyspark\n\n# Em desenvolvimento verificamos que a base order apresentava duplicidade devido a registros inválidos na data do pedido\n# Vamos tratá-los considerando todo registro que tiver na diferença created_at e order_created_at um valor menor ou igual a 1 como válido\njoin00_ = join00 \\\n    .withColumn(\"order_created_at\", col(\"order_created_at\").cast(TimestampType())) \\\n    .withColumn(\"created_at\", col(\"created_at\").cast(TimestampType())) \\\n    .withColumn(\"fl_valid\", expr(\"case when datediff(created_at, order_created_at) <= 1 then 1 else 0 end\")) \\\n    .filter(col(\"fl_valid\") == 1) \\\n    .drop(\"fl_valid\", \"created_at\")","user":"anonymous","dateUpdated":"2019-12-25T11:09:48-0300","config":{"editorSetting":{"language":"python","editOnDblClick":false,"completionKey":"TAB","completionSupport":true},"colWidth":12,"editorMode":"ace/mode/python","fontSize":9,"title":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[]},"apps":[],"jobName":"paragraph_1577281242314_-899205027","id":"20191223-125627_1436993064","dateCreated":"2019-12-25T10:40:42-0300","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:2444","dateFinished":"2019-12-25T11:09:48-0300","dateStarted":"2019-12-25T11:09:48-0300"},{"title":"Cruzamento com as bases consumer e restaurant","text":"%pyspark\n\n# Otimização do join\njoin00_ \\\n    .write.mode(\"overwrite\") \\\n    .bucketBy(int(spark.conf.get(\"spark.default.parallelism\")), \"customer_id\") \\\n    .option(\"compression\", \"snappy\") \\\n    .format(\"parquet\") \\\n    .saveAsTable(\"temp00\")\n\ntemp00DF = spark.read.table(\"temp00\")\n\nconsDF \\\n    .drop(\"customer_name\") \\\n    .withColumn(\"created_at\", col(\"created_at\").cast(TimestampType())) \\\n    .withColumnRenamed(\"created_at\", \"costumer_created_at\") \\\n    .write.mode(\"overwrite\") \\\n    .bucketBy(int(spark.conf.get(\"spark.default.parallelism\")), \"customer_id\") \\\n    .option(\"compression\", \"snappy\") \\\n    .format(\"parquet\") \\\n    .saveAsTable(\"consumer\")\n\nconsDF_ = spark.read.table(\"consumer\")\n\nrestDF \\\n    .withColumn(\"created_at\", col(\"created_at\").cast(TimestampType())) \\\n    .withColumnRenamed(\"id\", \"merchant_id\") \\\n    .withColumnRenamed(\"created_at\", \"merchant_created_at\") \\\n    .write.mode(\"overwrite\") \\\n    .bucketBy(int(spark.conf.get(\"spark.default.parallelism\")), \"merchant_id\") \\\n    .option(\"compression\", \"snappy\") \\\n    .format(\"parquet\") \\\n    .saveAsTable(\"restaurant\")\n\nrestDF_ = spark.read.table(\"restaurant\")\n\n# Traz todas as variáveis de consumer\njoin01 = temp00DF.join(consDF_, on=[\"customer_id\"], how=\"left\")\n\njoin01 \\\n    .write.mode(\"overwrite\") \\\n    .bucketBy(int(spark.conf.get(\"spark.default.parallelism\")), \"merchant_id\") \\\n    .option(\"compression\", \"snappy\") \\\n    .format(\"parquet\") \\\n    .saveAsTable(\"temp01\")\n\ntemp01DF = spark.read.table(\"temp01\")\n\n# Traz todas as variáveis de restaurant\njoin02 = temp01DF.join(restDF_, on=[\"merchant_id\"], how=\"left\")","user":"anonymous","dateUpdated":"2019-12-25T11:09:57-0300","config":{"editorSetting":{"language":"python","editOnDblClick":false,"completionKey":"TAB","completionSupport":true},"colWidth":12,"editorMode":"ace/mode/python","fontSize":9,"title":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[]},"apps":[],"jobName":"paragraph_1577281242317_2096392290","id":"20191223-140051_1115511627","dateCreated":"2019-12-25T10:40:42-0300","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:2445","dateFinished":"2019-12-25T11:57:13-0300","dateStarted":"2019-12-25T11:09:57-0300"},{"title":"Criptografando os dados sensíveis","text":"%pyspark\n\n# Criptografa os dados sensíveis\ncriptoDF = join02.select(criptografa_df(join02, cripto_ls))","user":"anonymous","dateUpdated":"2019-12-25T11:11:57-0300","config":{"editorSetting":{"language":"python","editOnDblClick":false,"completionKey":"TAB","completionSupport":true},"colWidth":12,"editorMode":"ace/mode/python","fontSize":9,"title":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[]},"apps":[],"jobName":"paragraph_1577281242319_-850441204","id":"20191223-145213_1760585040","dateCreated":"2019-12-25T10:40:42-0300","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:2446","dateFinished":"2019-12-25T11:57:16-0300","dateStarted":"2019-12-25T11:57:13-0300"},{"title":"Gera a base final trusted orders","text":"%pyspark\n\n# Renomeia as colunas e cria as partições para gravação\ntrustedDF = criptoDF \\\n    .select(colunas) \\\n    .withColumn(\"dt_proc\", current_date()) \\\n    .withColumn(\"dt\", from_utc_timestamp(\"order_created_at\", col(\"merchant_timezone\"))) \\\n    .withColumn(\"dt\", col(\"dt\").cast(DateType())) \\\n    .repartition(\"dt\")\n\ntrustedDF.write.mode(\"overwrite\").partitionBy(\"dt\").option(\"compression\", \"snappy\").format(\"parquet\").save(destino_trusted)","user":"anonymous","dateUpdated":"2019-12-25T11:12:00-0300","config":{"editorSetting":{"language":"python","editOnDblClick":false,"completionKey":"TAB","completionSupport":true},"colWidth":12,"editorMode":"ace/mode/python","fontSize":9,"title":true,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[]},"apps":[],"jobName":"paragraph_1577281242321_920396820","id":"20191223-155858_1997045721","dateCreated":"2019-12-25T10:40:42-0300","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:2447","dateFinished":"2019-12-25T12:02:40-0300","dateStarted":"2019-12-25T11:57:16-0300"},{"text":"%pyspark\nspark.read.parquet(destino_trusted).printSchema()","user":"anonymous","dateUpdated":"2019-12-25T12:54:45-0300","config":{"editorSetting":{"language":"python","editOnDblClick":false,"completionKey":"TAB","completionSupport":true},"colWidth":12,"editorMode":"ace/mode/python","fontSize":9,"results":{},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1577281242322_437627043","id":"20191223-231218_2053687780","dateCreated":"2019-12-25T10:40:42-0300","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:2448","dateFinished":"2019-12-25T12:54:46-0300","dateStarted":"2019-12-25T12:54:45-0300","results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"root\n |-- order_id: string (nullable = true)\n |-- customer_id: string (nullable = true)\n |-- customer_cpf: string (nullable = true)\n |-- customer_name: string (nullable = true)\n |-- customer_phone_area: string (nullable = true)\n |-- customer_phone_number: string (nullable = true)\n |-- customer_language: string (nullable = true)\n |-- costumer_created_at: timestamp (nullable = true)\n |-- is_costumer_active: string (nullable = true)\n |-- merchant_id: string (nullable = true)\n |-- merchant_created_at: timestamp (nullable = true)\n |-- is_merchant_enabled: string (nullable = true)\n |-- merchant_price_range: string (nullable = true)\n |-- merchant_average_ticket: string (nullable = true)\n |-- merchant_takeout_time: string (nullable = true)\n |-- merchant_delivery_time: string (nullable = true)\n |-- merchant_minimum_order_value: string (nullable = true)\n |-- merchant_zip_code: string (nullable = true)\n |-- merchant_city: string (nullable = true)\n |-- merchant_state: string (nullable = true)\n |-- merchant_country: string (nullable = true)\n |-- merchant_latitude: string (nullable = true)\n |-- merchant_longitude: string (nullable = true)\n |-- merchant_timezone: string (nullable = true)\n |-- delivery_address_city: string (nullable = true)\n |-- delivery_address_country: string (nullable = true)\n |-- delivery_address_district: string (nullable = true)\n |-- delivery_address_external_id: string (nullable = true)\n |-- delivery_address_latitude: string (nullable = true)\n |-- delivery_address_longitude: string (nullable = true)\n |-- delivery_address_state: string (nullable = true)\n |-- delivery_address_zip_code: string (nullable = true)\n |-- order_items: array (nullable = true)\n |    |-- element: struct (containsNull = true)\n |    |    |-- name: string (nullable = true)\n |    |    |-- addition: struct (nullable = true)\n |    |    |    |-- value: string (nullable = true)\n |    |    |    |-- currency: string (nullable = true)\n |    |    |-- discount: struct (nullable = true)\n |    |    |    |-- value: string (nullable = true)\n |    |    |    |-- currency: string (nullable = true)\n |    |    |-- quantity: double (nullable = true)\n |    |    |-- sequence: integer (nullable = true)\n |    |    |-- unitPrice: struct (nullable = true)\n |    |    |    |-- value: string (nullable = true)\n |    |    |    |-- currency: string (nullable = true)\n |    |    |-- externalId: string (nullable = true)\n |    |    |-- totalValue: struct (nullable = true)\n |    |    |    |-- value: string (nullable = true)\n |    |    |    |-- currency: string (nullable = true)\n |    |    |-- customerNote: string (nullable = true)\n |    |    |-- garnishItems: array (nullable = true)\n |    |    |    |-- element: struct (containsNull = true)\n |    |    |    |    |-- name: string (nullable = true)\n |    |    |    |    |-- addition: struct (nullable = true)\n |    |    |    |    |    |-- value: string (nullable = true)\n |    |    |    |    |    |-- currency: string (nullable = true)\n |    |    |    |    |-- discount: struct (nullable = true)\n |    |    |    |    |    |-- value: string (nullable = true)\n |    |    |    |    |    |-- currency: string (nullable = true)\n |    |    |    |    |-- quantity: double (nullable = true)\n |    |    |    |    |-- sequence: integer (nullable = true)\n |    |    |    |    |-- unitPrice: struct (nullable = true)\n |    |    |    |    |    |-- value: string (nullable = true)\n |    |    |    |    |    |-- currency: string (nullable = true)\n |    |    |    |    |-- categoryId: string (nullable = true)\n |    |    |    |    |-- externalId: string (nullable = true)\n |    |    |    |    |-- totalValue: struct (nullable = true)\n |    |    |    |    |    |-- value: string (nullable = true)\n |    |    |    |    |    |-- currency: string (nullable = true)\n |    |    |    |    |-- categoryName: string (nullable = true)\n |    |    |    |    |-- integrationId: string (nullable = true)\n |    |    |-- integrationId: string (nullable = true)\n |    |    |-- totalAddition: struct (nullable = true)\n |    |    |    |-- value: string (nullable = true)\n |    |    |    |-- currency: string (nullable = true)\n |    |    |-- totalDiscount: struct (nullable = true)\n |    |    |    |-- value: string (nullable = true)\n |    |    |    |-- currency: string (nullable = true)\n |-- order_created_at: timestamp (nullable = true)\n |-- is_order_scheduled: boolean (nullable = true)\n |-- order_scheduled_date: string (nullable = true)\n |-- order_total_amount: double (nullable = true)\n |-- origin_platform: string (nullable = true)\n |-- order_status: string (nullable = true)\n |-- dt_proc: date (nullable = true)\n |-- dt: date (nullable = true)\n\n"}]}},{"text":"%pyspark\n","user":"anonymous","dateUpdated":"2019-12-25T12:16:30-0300","config":{"colWidth":12,"fontSize":9,"enabled":true,"results":{},"editorSetting":{"language":"python","editOnDblClick":false,"completionKey":"TAB","completionSupport":true},"editorMode":"ace/mode/python"},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1577286990078_-515581059","id":"20191225-121630_1472738373","dateCreated":"2019-12-25T12:16:30-0300","status":"READY","progressUpdateIntervalMs":500,"focus":true,"$$hashKey":"object:3583"}],"name":"ifood-trusted-order-dev","id":"2EVC1GZSF","noteParams":{},"noteForms":{},"angularObjects":{"spark:shared_process":[]},"config":{"isZeppelinNotebookCronEnable":false,"looknfeel":"default","personalizedMode":"false"},"info":{}}